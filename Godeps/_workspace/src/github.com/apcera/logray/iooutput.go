// Copyright 2012-2014 Apcera Inc. All rights reserved.

// This is geared towards ANSI output and the original intention was that this
// file not be used on Windows; if you implement a solution which will work on
// Windows as an alternative to this file, go ahead and restrict the build.  We
// just dropped the build constraint to get a working logging module on Windows.

package logray

// This file contains an Output implementation that is designed to work on Unix
// based systems, where colorization can be done via control codes in the
// output. This does not work on Windows as color changes can only be done once
// data has been written to the output so the implementation is different.

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"
)

// Interface for objects with a Flush call. This is used with ioOutput to
// implement Flush() only if the underlying object supports it as well.
type flushWriter interface {
	Flush() error
}

// Interface for objects with a Sync call. This is used with ioOutput to
// implement Flush() only if the underlying object supports it as well.
type syncWriter interface {
	Sync() error
}

var (
	// The default format string that will be applied when outputs are created.
	DefaultFormatString = "" +
		"%color:class%[%classfixed% " +
		"%year%-%month%-%day% %hour%:%minute%:%second%.%nanosecond% " +
		"%tzoffset% %tz% pid=%pid%" +
		"]%color:default% " +
		"%message%"
)

// An implementation of Output that uses io.Writer as its output object.  This
// is used for all output types that just wrap an io.Writer object.  Note that
// if the underlying io.Writer also has a Flush() function it will be called
// when the Output module Flushes.
type ioOutput struct {
	// The list of functions that will be called in order to fill the bytes.Buffer
	// when forming a new log line.
	formatFuncs []func(*LineData, *bytes.Buffer) error

	// The estimated static content within the log message. This is used to size
	// the buffer when preallocating.
	initialSize int

	// The io.Writer that log data will be written too.
	writer io.Writer
}

// This function creates a special case of the Output object which will write to
// the given io.Writer interface. This special case supports formatting as well
// as colorization where possible.
//
// See the Examples section of the godoc for examples of how to use this with
// custom code.
//
// The format string defined in "format" follows a syntax where a code is
// surrounded by percent signs. What follows is a list of the working codes
// supported by the format function.
//    %% - Replaced with a literal percent sign.
//    %class% - Replaced with the uppercase string representation of the
//        class used to generate the given log line. Examples of this field
//        are 'INFO' or 'ERROR'.
//    %classfixed% - Replaced with the uppercase string representation of the
//        class used to generate the given log line, fixed to 5 characters
//        width. Similar to %class%, but will pad the text to ensure a
//        consistent width.
//    %message% - Replaced with the message generated when logging. This is
//        the string ultimately generated by the call to functions like Infof()
//    %nanosecond% - Replaced with the number of nanoseconds elapsed since the
//        start of the last second in the time stamp. This will always be
//        a 9 digit number from 000000000 to 999999999.
//    %second% - Replaced with the number of seconds that have elapsed since
//        the start of the last minute in the time stamp. This will always
//        be a 2 digit number from 00 to 59
//    %minute% - Replaced with the number of minutes that have elapsed since
//        the start of the last hour in the time stamp. This will always be
//        a 2 digit number from 00 to 59.
//    %hour% - Replaced with the number of hours that have elapsed since the
//        start of the day in the time stamp. This is 24 hour format, and as
//        such will be a 2 digit number between 00 and 23
//    %day% - Replaced with the number of days that have elapsed from the
//        start of the month in the time stamp. This will always be a 2
//        digit number between 01 and 31
//    %month% - Replaced with the number of months elapsed since the start
//        of the year. This will always be a 2 digit number between 01 and 12.
//    %year% - Replaced with the number of years since the start of the
//        common era. This will always be a four digit number between 0000
//        and 9999, however it will most likely take the form: 2013, 2014, etc.
//    %epoch% - Replaced with the number of seconds that have elapsed since
//        the Unix standard epoch (Midnight, Jan 1, 1970, UTC) less leap
//        seconds. See http://en.wikipedia.org/wiki/Unix_time
//    %tzoffset% - Replaced with a decimal representation of the offset for
//        a given timezone. This will be a 4 digit number, prefaced with either
//        a + or a - sign. An example of this is: -0600 MDT, or +0000 GMT
//    %tz% - A string representation of the current time zone. This is a
//        three to four character string of the form: PDT, PST, EST, UTC, etc.
//    %hostname% - Replaced with the current hostname of the machine.
//    %pid% - The PID of the current process.
//
// There are also special color codes which allow color to be inserted into the
// stream. These are optionally inserted based on the value of the parameter
// "color". Colors are enabled for the following values: on, yes, true; and will
// be disabled for the following values: off, no, false. Additionally if the
// value is an empty string, or auto then the output module will attempt to
// detect color support by looking to see if the output device is a terminal.
//
// The following color tags exist, if color is disabled then these will inject
// nothing into the stream, otherwise they will insert the ANSI codes required
// to change the color to the given value. Do not forget to reset color coding
// at the end of the format string by using: %color:default%.
//
// Supported codes:
//   %color:black% - Changes the color for following text to black.
//   %color:bright-black% - Changes the color for following text to black.
//   %color:blue% - Changes the color for following text to blue.
//   %color:bright-blue% - Changes the color for following text
//       to bright blue.
//   %color:cyan% - Changes the color for following text to cyan.
//   %color:bright-cyan% - Changes the color for following text
//       to bright cyan.
//   %color:green% - Changes the color for following text to green.
//   %color:bright-green% - Changes the color for following text
//       to bright green.
//   %color:magenta% - Changes the color for following text to magenta.
//   %color:bright-magenta% - Changes the color for following text
//       to bright magenta.
//   %color:red% - Changes the color for following text to red.
//   %color:bright-red% - Changes the color for following text to bright red.
//   %color:white% - Changes the color for following text to a
//       dim white which usually appears grey.
//   %color:bright-white% - Changes the color for following text to white.
//   %color:yellow% - Changes the color for following text to yellow.
//   %color:bright-yellow% - Changes the color for following text to
//       bright yellow.
//
//   %color:default% - Resets the color to the default color for the console.
//   %color:class% - Sets the color to the color associated with the class
//       of the log line being written. This is used to change the
//       output color to differentiate lines visually. The default colors are:
//         DEBUG: grey
//         TRACE: grey
//         INFO: green
//         WARN: yellow
//         ERROR: red
//         FATAL: magenta
//
// On success an Output interface will be returned, other wise Output will be
// nil and an error will be returned. The format string is parsed during this
// call in order to reduce the expense of logging a single line. This means that
// formatting errors like using an unsupported code, forgetting to close a code
// and such will return an error here, which in turn prevents the output from
// being used.
func NewIOWriterOutput(w io.Writer, format string, color string) (Output, error) {
	// Set defaults for color and format if they are not currently defined.
	if format == "" {
		format = DefaultFormatString
	}

	// This is the table/state manager used to parse the format string.
	fp := formatParser{
		format: format,

		// Starting table states.
		next: (*formatParser).freshNext,
		code: (*formatParser).freshCode,
		end:  (*formatParser).freshEnd,
	}

	// See if we should enable color codes for this output.
	if color == "on" || color == "true" || color == "yes" {
		fp.color = true
	} else if color == "off" || color == "false" || color == "no" {
		fp.color = false
	} else if color == "auto" || color == "" {
		if fd, ok := w.(*os.File); ok {
			fp.color = isTerminal(fd)
		} else {
			fp.color = false
		}
	} else {
		return nil, fmt.Errorf("Unknown color setting: %s", color)
	}

	// Walk through the format string one rune at a time calling the appropriate
	// state transition function based on the rune that is received.
	for i, r := range format {
		if r == '%' {
			if err := fp.code(&fp, i, r); err != nil {
				return nil, err
			}
		} else {
			if err := fp.next(&fp, i, r); err != nil {
				return nil, err
			}
		}
	}

	// Call the end function to see if ending the format in this state is invalid.
	if err := fp.end(&fp); err != nil {
		return nil, err
	}

	o := new(ioOutput)
	o.writer = w
	o.formatFuncs = fp.formatFuncs
	o.initialSize = fp.initialSize
	return o, nil
}

// Write attempts to add a line to this output object. This may be buffered, or
// unbuffered so its not safe to assume that this call will not block.
func (o *ioOutput) Write(ld *LineData) error {
	size := o.initialSize + len(ld.Message) + 1
	buffer := bytes.NewBuffer(make([]byte, 0, size))

	// Walk the formatting functions calling them so they can write to the output
	// buffer where possible.
	for _, f := range o.formatFuncs {
		if err := f(ld, buffer); err != nil {
			return err
		}
	}

	// Return the bytes that we generated in the functions above.
	data := buffer.Bytes()
	if len(data) == 0 || data[len(data)-1] != '\n' {
		if err := buffer.WriteByte('\n'); err != nil {
			return err
		}
	}

	// Write the data in the buffer to the output writer.
	if _, err := o.writer.Write(buffer.Bytes()); err != nil {
		return err
	}
	return nil
}

// Flushes all logs that have been buffered for writing to this output.
func (o *ioOutput) Flush() error {
	if w, ok := o.writer.(flushWriter); ok {
		return w.Flush()
	}
	if w, ok := o.writer.(syncWriter); ok {
		return w.Sync()
	}
	return nil
}

// -------------------------------------------
// Helper structure for parsing format strings
// -------------------------------------------

// A simple object used to render format function custom bytes.
type staticBytes []byte

// Can be used in the formatFuncs array
func (s staticBytes) formatFunc(ld *LineData, b *bytes.Buffer) error {
	_, err := b.Write([]byte(s))
	return err
}

// This is a very simple table/state based tokenizer and parser.
type formatParser struct {
	// The format string being parsed.
	format string

	// The start of the current token being parsed.
	start int

	// Stores the last static element received. This is used to ensure that we
	// merge static elements together to reduce the formatting time. If this is
	// nil, or length is 0 then no previous static element was parsed.
	lastStatic []byte

	// The list of parsing functions.
	formatFuncs []func(*LineData, *bytes.Buffer) error

	// The total preallocated size for the buffer.
	initialSize int

	// Should ANSI color codes be added?
	color bool

	// Called if the next item in the format string is a code ('%')
	code func(fp *formatParser, i int, r rune) error

	// Called if the next item in the format astring is not a code.
	next func(fp *formatParser, i int, r rune) error

	// Called at the end of parsing the format string.
	end func(fp *formatParser) error
}

// Adds a static string to the formatFuncs implementation.
func (fp *formatParser) addStatic(b []byte) {
	if b == nil {
		return
	} else if len(fp.lastStatic) == 0 {
		fp.lastStatic = b
	} else {
		fp.lastStatic = append(fp.lastStatic, b...)
	}
}

// Called when a series of static strings has ended.
func (fp *formatParser) commitStatic() {
	if len(fp.lastStatic) == 0 {
		return
	}
	f := staticBytes(fp.lastStatic).formatFunc
	fp.formatFuncs = append(fp.formatFuncs, f)
	fp.initialSize += len(fp.lastStatic)
	fp.lastStatic = nil
}

// Adds a format function to the formatFunc list.
func (fp *formatParser) addFormatFunc(
	f func(*LineData, *bytes.Buffer) error, size int,
) {
	fp.commitStatic()
	fp.formatFuncs = append(fp.formatFuncs, f)
	fp.initialSize += size
}

// Called when the parser is not currently parsing a static string and the next
// character in the format string is a code '%'.
func (fp *formatParser) freshCode(i int, r rune) error {
	fp.start = i
	fp.code = (*formatParser).codeCode
	fp.next = (*formatParser).codeNext
	fp.end = (*formatParser).codeEnd
	return nil
}

// Called when the parser is not currently parsing a static string and the next
// character in the format string is not a '%'.
func (fp *formatParser) freshNext(i int, r rune) error {
	fp.start = i
	fp.code = (*formatParser).staticCode
	fp.next = (*formatParser).staticNext
	fp.end = (*formatParser).staticEnd
	return nil
}

// Called when the parser is not currently parsing a static string and the end
// of the format string is reached.
func (fp *formatParser) freshEnd() error {
	fp.commitStatic()
	return nil
}

// Called when processing a code string and another '%' is found in the format
// string.
func (fp *formatParser) codeCode(i int, r rune) error {
	fp.processCode(i)
	fp.start = i
	fp.code = (*formatParser).freshCode
	fp.next = (*formatParser).freshNext
	fp.end = (*formatParser).freshEnd
	return nil
}

// Called when the formatting string is parsing a code rather than a static
// string. Codes are enclosed in '%' objects and must match specific patterns.
func (fp *formatParser) codeNext(i int, r rune) error {
	return nil
}

// Called when the end of the format stream is reached while processing a code
// string.
func (fp *formatParser) codeEnd() error {
	return fmt.Errorf("Unclosed code at index: %d", fp.start)
}

// Called when processing a static string and a code '%' is found.
func (fp *formatParser) staticCode(i int, r rune) error {
	data := []byte(fp.format[fp.start:i])
	fp.addStatic(data)
	fp.start = i
	fp.code = (*formatParser).codeCode
	fp.next = (*formatParser).codeNext
	fp.end = (*formatParser).codeEnd
	return nil
}

// Called when processing a static string and a non coded rune is found.
func (fp *formatParser) staticNext(i int, r rune) error {
	return nil
}

// Called when processing a static string and the end of the format string is
// found.
func (fp *formatParser) staticEnd() error {
	fp.addStatic([]byte(fp.format[fp.start:]))
	fp.commitStatic()
	return nil
}

// Processes codes, adds them to the lastStatic object if necessary, otherwise
// adds a function to the function list.
func (fp *formatParser) processCode(index int) error {
	code := fp.format[fp.start+1 : index]
	switch {
	case code == "":
		fp.addStatic([]byte("%"))

		// LineData strings.
	case code == "class":
		fp.addFormatFunc(ioOutputFormatClass, 6)
	case code == "classfixed":
		fp.addFormatFunc(ioOutputFormatClassFixed, 5)
	case code == "message":
		// len(ld.Message) already gets added into the buffer.
		fp.addFormatFunc(ioOutputFormatMessage, 0)

		// Time format functions.
	case code == "nanosecond":
		fp.addFormatFunc(ioOutputFormatNanoSecond, 9)
	case code == "second":
		fp.addFormatFunc(ioOutputFormatSecond, 2)
	case code == "minute":
		fp.addFormatFunc(ioOutputFormatMinute, 2)
	case code == "hour":
		fp.addFormatFunc(ioOutputFormatHour, 2)
	case code == "day":
		fp.addFormatFunc(ioOutputFormatDay, 2)
	case code == "month":
		fp.addFormatFunc(ioOutputFormatMonth, 2)
	case code == "year":
		fp.addFormatFunc(ioOutputFormatYear, 4)
	case code == "epoch":
		fp.addFormatFunc(ioOutputFormatEpoch, 10)
	case code == "tzoffset":
		fp.addFormatFunc(ioOutputFormatTZOffset, 5)
	case code == "tz":
		fp.addFormatFunc(ioOutputFormatTZ, 4)

		// System level tools.
	case code == "hostname":
		fp.addFormatFunc(ioOutputFormatHostname, 4)
	case code == "pid":
		fp.addFormatFunc(ioOutputFormatPid, 0)

		// Calling code fields.
	case code == "package":
		fp.addFormatFunc(ioOutputFormatPackage, 0)
	case code == "function":
		fp.addFormatFunc(ioOutputFormatFunction, 0)
	case code == "sourcefile":
		fp.addFormatFunc(ioOutputFormatSourceFile, 0)
	case code == "sourceline":
		fp.addFormatFunc(ioOutputFormatSourceLine, 0)

		// Field access.
	case strings.HasPrefix(code, "field:"):
		if len(code) < 7 {
			return fmt.Errorf("Color code left empty.")
		}
		fp.addFormatFunc(ioOutputFormatField(code[6:]), 0)

		// Color:
	case strings.HasPrefix(code, "color:"):
		if len(code) < 7 {
			return fmt.Errorf("Color code left empty.")
		}
		if err := fp.setAnsiColor(code[6:]); err != nil {
			return err
		}

	default:
		// Unknown
		return fmt.Errorf("Unknown format code: %s", code)
	}
	return nil
}

// Adds a static string with the given ANSI color code.
func (fp *formatParser) setAnsiColor(name string) error {
	// If colors are not enabled then do not add strings in this function.
	if fp.color == false {
		return nil
	}
	if ansi, ok := ioOutputColorMap[name]; ok {
		fp.addStatic(ansi)
		return nil
	} else if name == "class" {
		// 10 bytes is a sane upper bound.
		fp.addFormatFunc(ioOutputFormatClassColor, 10)
		return nil
	}
	return fmt.Errorf("Unknown color name: %s", name)
}

// Formatting function used to implement the %class% code.
func ioOutputFormatClass(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(strings.ToUpper(ld.Class.String()))
	return err
}

// Formatting function used to implement the %classfixed% code.
func ioOutputFormatClassFixed(ld *LineData, b *bytes.Buffer) error {
	class := strings.ToUpper(ld.Class.String())
	switch len(class) {
	case 4:
		class += " "
	case 6:
		class = class[:5]
	}
	_, err := b.WriteString(class)
	return err
}

// Formatting function used to implement the %message% code.
func ioOutputFormatMessage(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(ld.Message)
	return err
}

// Formatting function used to implement the %nanosecond% code.
func ioOutputFormatNanoSecond(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%09d", ld.TimeStamp.Nanosecond()))
	return err
}

// Formatting function used to implement the %second% code.
func ioOutputFormatSecond(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%02d", ld.TimeStamp.Second()))
	return err
}

// Formatting function used to implement the %minute% code.
func ioOutputFormatMinute(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%02d", ld.TimeStamp.Minute()))
	return err
}

// Formatting function used to implement the %hour% code.
func ioOutputFormatHour(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%02d", ld.TimeStamp.Hour()))
	return err
}

// Formatting function used to implement the %day% code.
func ioOutputFormatDay(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%02d", ld.TimeStamp.Day()))
	return err
}

// Formatting function used to implement the %month% code.
func ioOutputFormatMonth(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%02d", int(ld.TimeStamp.Month())))
	return err
}

// Formatting function used to implement the %year% code.
func ioOutputFormatYear(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%04d", ld.TimeStamp.Year()))
	return err
}

// Formatting function used to implement the %epoch% code.
func ioOutputFormatEpoch(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%d", int(ld.TimeStamp.Unix())))
	return err
}

// Formatting function used to implement the %tzoffset% code.
func ioOutputFormatTZOffset(ld *LineData, b *bytes.Buffer) error {
	_, offset := ld.TimeStamp.Zone()
	hour := offset / (60 * 60)
	minute := (offset / 60) % 60
	c := "-"
	if hour >= 0 {
		c = "+"
	} else {
		hour *= -1
	}
	_, err := b.WriteString(fmt.Sprintf("%s%02d%02d", c, hour, minute))
	return err
}

// Formatting function used to implement the %tz% code.
func ioOutputFormatTZ(ld *LineData, b *bytes.Buffer) error {
	name, _ := ld.TimeStamp.Zone()
	_, err := b.WriteString(name)
	return err
}

// Formatting function used to implement the %hostname% code.
func ioOutputFormatHostname(ld *LineData, b *bytes.Buffer) error {
	name, err := os.Hostname()
	if err != nil {
		return err
	}
	_, err = b.WriteString(name)
	return err
}

// Formatting function used to implement the %pid% code
func ioOutputFormatPid(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%d", os.Getpid()))
	return err
}

// Formatting function used to implement the %package% code
func ioOutputFormatPackage(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(ld.CallingPackage)
	return err
}

// Formatting function used to implement the %function% code
func ioOutputFormatFunction(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(ld.CallingFunction)
	return err
}

// Formatting function used to implement the %sourcefile% code
func ioOutputFormatSourceFile(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(ld.SourceFile)
	return err
}

// Formatting function used to implement the %sourceline% code
func ioOutputFormatSourceLine(ld *LineData, b *bytes.Buffer) error {
	_, err := b.WriteString(fmt.Sprintf("%d", ld.SourceLine))
	return err
}

// Formatting functoin used to implement the %field:XX% code
func ioOutputFormatField(field string) func(*LineData, *bytes.Buffer) error {
	return func(ld *LineData, b *bytes.Buffer) error {
		v, exist := ld.Fields[field]
		if !exist {
			return nil
		}
		_, err := b.WriteString(fmt.Sprintf("%v", v))
		return err
	}
}

// Formatting function used to implement the %color:class% code.
func ioOutputFormatClassColor(ld *LineData, b *bytes.Buffer) error {
	switch ld.Class {
	case TRACE:
		_, err := b.Write(ioOutputColorMap["crazy"])
		return err
	case DEBUG:
		_, err := b.Write(ioOutputColorMap["half-crazy"])
		return err
	case INFO:
		_, err := b.Write(ioOutputColorMap["cyan"])
		return err
	case WARN:
		_, err := b.Write(ioOutputColorMap["yellow"])
		return err
	case ERROR:
		_, err := b.Write(ioOutputColorMap["red"])
		return err
	case FATAL:
		_, err := b.Write(ioOutputColorMap["magenta"])
		return err
	}
	_, err := b.Write(ioOutputColorMap["default"])
	return err
}
